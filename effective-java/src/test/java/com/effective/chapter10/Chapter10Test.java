package com.effective.chapter10;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

@DisplayName("异常")
public class Chapter10Test {

    /**
     * 69. 只针对异常的情况才使用异常
     * 70. 对于可恢复的情况使用受检异常，对编程错误使用运行时异常
     * 71. 避免不必要的使用受检异常
     * 72. 优先使用标准异常
     */
    @Test
    public void test69() {
        // 异常应该只用于异常的情况下，不应该用于正常的控制流
        // 设计良好的api不应该强迫客户端为了正常的控制流使用异常

        // 如果希望调用者能够适当的恢复，就应该使用受检异常
        // 用运行时异常表明编程错误
        // 不要实现任何新的Error子类，自己实现的所有受检异常都应该是 RuntimeException 的子类
    }

    /**
     * 73. 抛出与抽象对应的异常
     */
    @Test
    public void test73() {
        // 异常转译：更高层的实现应该捕获底层的异常，同时抛出可以按照高层抽象进行解释的异常
    }

    /**
     * 74. 每个方法抛出的异常都要建立文档
     */
    @Test
    public void test74() {
        // 单独声明受检异常，准确记录抛出异常的条件
        // @throws 记录该方法可能抛出的未受检异常，不要在方法签名上声明未受检异常
    }

    /**
     * 75. 在细节信息中包含失败捕获信息
     * 76. 使失败保持原子性(多用于并发)
     */
    @Test
    public void test75() {
        // 为了捕获异常，异常的细节信息应该包含 “对异常有贡献” 的所有参数和域的值
        // 不要在细节信息中包含密码密钥及类似信息

        // 失败的方法调用应该使对象保持在被调用之前的状态
        // 使用不可变类
        // 执行操作之前检查参数有效性
        // 调整计算处理过程的顺序，使任何可能会失败的计算部分在对象状态改变之前发生
        // 在对象的一份临时拷贝上执行操作，操作完成之后用临时对象替换原始对象
        // 编写一段恢复代码来拦截操作过程中发生的失败，使对象回滚到操作开始之前的状态(针对永久性的数据结构(磁盘))
    }

    /**
     * 77. 不要忽略异常
     */
    @Test
    public void test77() {
        // 空的 catch 达不到应有的目的
        // 如果选择忽略异常，应该在 catch 中用注释说明为什么这么做，将变量名改为 ignored
    }
}
