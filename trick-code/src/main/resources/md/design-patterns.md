

#### 简单工厂

创建一个类通过switch case 创建对应的对象 (这里不符合 开放封闭 原则，添加新操作时候需要添加 case)

- 聚合：关系较弱

- 组合：部分和整体生命周期一样



#### 工厂方法

定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。



#### 策略

策略模式是一种定义一系列算法的方法，从概念上来看，所有这些算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合；

策略模式的Strategy类层次为Context定义了一系列的可供重用的算法或行为。继承有助于析取出这些算法中的公共功能；

当不同的行为堆砌在一个类中时，就很难避免使用条件语句来选择合适的行为。将这些行为封装在一个个独立的Strategy类中，可以在使用这些行为的类中消除条件语句；

简化了单元测试，**封装了变化**



#### 单一职责原则 (SRP)

就一个类而言，应该仅有一个引起它变化的原因



#### 开放封闭原则 (Open closed principle)

对扩展开放，对修改关闭；

设计人员必须对于他设计的模块应该对哪种变化封闭做出选择。他必须先猜测出最有可能发生的变化种类，**然后构造抽象来隔离那些变化**；面对需求，对程序的改动是通过**增加新代码**进行的，而不是更改现有的代码



#### 依赖倒置原则

抽象不应该依赖细节，细节应该依赖于抽象；

针对接口编程，不要对实现编程；高层模块不应该依赖低层模块。两个都应该依赖抽象；抽象不应该依赖细节，细节应该依赖抽象

依赖倒转其实可以说是面向对象设计的标志，用哪种语言来编写程序不重要，如果编写时考虑的都是如何**针对抽象编程**而不是针对细节编程，即程序中所有的依赖关系都是终止于抽象类或者接口，那就是面向对象的设计，反之那就是过程化的设计了



#### 里氏替换原则

子类型必须能够替**换掉**它们的父类型

一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。也就是说，在软件里面，把父类都替换成它的子类，程序的行为没有变化；只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为

由于子类型的可替换性才使得使用父类类型的模块在无需修改的情况下就可以扩展



#### 迪米塔法则

如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性



#### 装饰器

被装饰的对象 和 装饰器本身 要实现同一个接口

当系统需要新功能的时候，是向旧的类中添加新的代码。这些新加的代码通常装饰了原有类的**核心职责**或主要行为



![装饰器模式的结构图](../img/装饰器模式的结构图.gif)



#### 代理

为其他对象提供一种代理以控制对这个对象的访问

代理类 和 被代理类 要实现同一个接口



#### 原型

Prototype，用原型实例指定创建对象的种类，并且通过**拷贝**这些原型创建新的对象



#### 模板方法

定义一个操作中的算法的**骨架**，而将一些步骤**延迟到子类**中。

模板方法将不变的行为移动到父类，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。



#### 外观(门面)模式

通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体细节

